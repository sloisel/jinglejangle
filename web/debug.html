<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cache Debug</title>
  <style>
    body { font-family: monospace; padding: 20px; }
    button { padding: 10px 20px; margin: 5px; font-size: 16px; }
    #output { white-space: pre-wrap; background: #f0f0f0; padding: 10px; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Service Worker & Cache Debug</h1>
  <p id="swstatus">Checking SW control...</p>
  <script>
    if (navigator.serviceWorker.controller) {
      document.getElementById('swstatus').textContent = 'SW controlling this page: ' + navigator.serviceWorker.controller.scriptURL;
    } else {
      document.getElementById('swstatus').textContent = 'NO service worker controlling this page!';
    }
  </script>

  <button onclick="checkSW()">Check Service Worker</button>
  <button onclick="registerSW()">Register Service Worker</button>
  <button onclick="unregisterSW()">Unregister All</button>
  <button onclick="listCache()">List Cached Files</button>
  <button onclick="testAssets()">Test Asset Fetches</button>
  <button onclick="testFullCache()">Test Full Cache (145 assets)</button>
  <button onclick="testAudio()">Test Audio Fetch</button>
  <button onclick="testFont()">Test Font Fetch</button>

  <div id="output">Click a button to test...</div>

  <script>
    const out = document.getElementById('output');

    async function unregisterSW() {
      out.textContent = 'Unregistering all service workers...\n';
      const regs = await navigator.serviceWorker.getRegistrations();
      for (const reg of regs) {
        await reg.unregister();
        out.textContent += `Unregistered: ${reg.scope}\n`;
      }
      out.textContent += 'Done. Reload the main app to test without service worker.\n';
    }

    async function registerSW() {
      out.textContent = 'Attempting to register service worker...\n';

      if (!('serviceWorker' in navigator)) {
        out.textContent += 'Service Worker NOT supported!\n';
        return;
      }

      try {
        const reg = await navigator.serviceWorker.register('flutter_service_worker.js');
        out.textContent += 'Registration returned!\n';
        out.textContent += `Scope: ${reg.scope}\n`;
        out.textContent += `Active: ${reg.active ? reg.active.state : 'none'}\n`;
        out.textContent += `Waiting: ${reg.waiting ? reg.waiting.state : 'none'}\n`;
        out.textContent += `Installing: ${reg.installing ? reg.installing.state : 'none'}\n`;

        // Check registrations immediately
        const regs = await navigator.serviceWorker.getRegistrations();
        out.textContent += `\nRegistrations count immediately after: ${regs.length}\n`;

        // Listen for state changes
        const worker = reg.installing || reg.waiting || reg.active;
        if (worker) {
          out.textContent += `\nWatching worker in state: ${worker.state}\n`;
          worker.addEventListener('statechange', (e) => {
            out.textContent += `State changed to: ${e.target.state}\n`;
          });
          worker.addEventListener('error', (e) => {
            out.textContent += `Worker ERROR: ${e.message}\n`;
          });
        }

        // Wait a second and check again
        setTimeout(async () => {
          const regs2 = await navigator.serviceWorker.getRegistrations();
          out.textContent += `\nRegistrations after 1 second: ${regs2.length}\n`;
          if (regs2.length === 0) {
            out.textContent += 'Service worker was UNREGISTERED!\n';
          }
        }, 1000);

      } catch (e) {
        out.textContent += `Registration FAILED: ${e}\n`;
        out.textContent += `Error name: ${e.name}\n`;
        out.textContent += `Error message: ${e.message}\n`;
      }
    }

    async function checkSW() {
      out.textContent = 'Checking service worker...\n';

      if (!('serviceWorker' in navigator)) {
        out.textContent += 'Service Worker NOT supported!\n';
        return;
      }

      const regs = await navigator.serviceWorker.getRegistrations();
      out.textContent += `Registrations: ${regs.length}\n`;

      for (const reg of regs) {
        out.textContent += `\nScope: ${reg.scope}\n`;
        out.textContent += `Active: ${reg.active ? reg.active.state : 'none'}\n`;
        out.textContent += `Waiting: ${reg.waiting ? reg.waiting.state : 'none'}\n`;
        out.textContent += `Installing: ${reg.installing ? reg.installing.state : 'none'}\n`;
      }
    }

    async function listCache() {
      out.textContent = 'Listing caches...\n';

      const cacheNames = await caches.keys();
      out.textContent += `Cache names: ${cacheNames.join(', ')}\n\n`;

      for (const name of cacheNames) {
        const cache = await caches.open(name);
        const keys = await cache.keys();
        out.textContent += `\n${name}: ${keys.length} items\n`;

        // Show first 30 URLs
        out.textContent += `  Sample URLs:\n`;
        keys.slice(0, 30).forEach(k => {
          out.textContent += `    ${k.url}\n`;
        });

        // Count by type
        const mp3s = keys.filter(k => k.url.includes('.mp3'));
        const fonts = keys.filter(k => k.url.includes('.ttf') || k.url.includes('.otf'));
        out.textContent += `\n  MP3 files: ${mp3s.length}\n`;
        out.textContent += `  Font files: ${fonts.length}\n`;
        out.textContent += `  Font URLs:\n`;
        fonts.forEach(k => {
          out.textContent += `    ${k.url}\n`;
        });
      }
    }

    async function testAssets() {
      out.textContent = 'Testing asset fetches...\n';

      const testUrls = [
        'main.dart.js',
        'flutter.js',
        'index.html',
        '/',
        'manifest.json',
        'assets/FontManifest.json',
        'assets/AssetManifest.bin.json',
        'assets/fonts/ackaisyo.ttf',
        'assets/assets/marina/0.mp3',
        'assets/assets/problemset.json',
        'canvaskit/canvaskit.js',
        'canvaskit/canvaskit.wasm',
      ];

      for (const url of testUrls) {
        try {
          const resp = await fetch(url, {cache: 'reload'});
          if (resp.ok) {
            out.textContent += `✓ ${url} (${resp.status})\n`;
          } else {
            out.textContent += `✗ ${url} (${resp.status} ${resp.statusText})\n`;
          }
        } catch (e) {
          out.textContent += `✗ ${url} (ERROR: ${e.message})\n`;
        }
      }

      out.textContent += '\nNow testing cache.addAll simulation...\n';

      try {
        const cache = await caches.open('test-cache');
        await cache.addAll(testUrls.map(u => new Request(u, {cache: 'reload'})));
        out.textContent += '✓ cache.addAll succeeded!\n';
        await caches.delete('test-cache');
      } catch (e) {
        out.textContent += `✗ cache.addAll FAILED: ${e.message}\n`;
      }

      out.textContent += '\nDone testing assets.\n';
    }

    async function testAudio() {
      const url = 'assets/assets/marina/0.mp3';
      out.textContent = `Testing fetch: ${url}\n`;

      try {
        const resp = await fetch(url);
        out.textContent += `Status: ${resp.status}\n`;
        out.textContent += `From cache: ${resp.headers.get('x-from-cache') || 'unknown'}\n`;
        out.textContent += `Content-Type: ${resp.headers.get('content-type')}\n`;
        out.textContent += `Content-Length: ${resp.headers.get('content-length')}\n`;

        // Try to play it
        const blob = await resp.blob();
        const audio = new Audio(URL.createObjectURL(blob));
        audio.play().then(() => {
          out.textContent += 'Audio played successfully!\n';
        }).catch(e => {
          out.textContent += `Audio play error: ${e}\n`;
        });
      } catch (e) {
        out.textContent += `Fetch error: ${e}\n`;
      }
    }

    async function testFont() {
      out.textContent = 'Testing font loading like Flutter does...\n';

      // Test 1: Simple fetch
      out.textContent += '\n1. Simple fetch:\n';
      try {
        const resp = await fetch('assets/fonts/ackaisyo.ttf');
        out.textContent += `   Status: ${resp.status}\n`;
      } catch (e) {
        out.textContent += `   Error: ${e.message}\n`;
      }

      // Test 2: Load as FontFace (how browsers actually load fonts)
      out.textContent += '\n2. FontFace API:\n';
      try {
        const font = new FontFace('TestKaisyo', 'url(assets/fonts/ackaisyo.ttf)');
        await font.load();
        document.fonts.add(font);
        out.textContent += '   FontFace loaded OK!\n';
      } catch (e) {
        out.textContent += `   FontFace error: ${e.message}\n`;
      }

      // Test 3: Test audio element (how audioplayers works)
      out.textContent += '\n3. Audio element:\n';
      try {
        const audio = document.createElement('audio');
        audio.src = 'assets/assets/marina/0.mp3';
        await new Promise((resolve, reject) => {
          audio.oncanplaythrough = resolve;
          audio.onerror = () => reject(new Error('Audio load failed: ' + audio.error?.message));
          setTimeout(() => reject(new Error('Audio load timeout')), 5000);
        });
        out.textContent += '   Audio loaded OK!\n';
        audio.play().catch(e => {}); // Try to play
      } catch (e) {
        out.textContent += `   Audio error: ${e.message}\n`;
      }

      // Test 4: Check what's online/offline
      out.textContent += '\n4. Network status: ' + (navigator.onLine ? 'ONLINE' : 'OFFLINE') + '\n';
    }
  </script>
</body>
</html>
